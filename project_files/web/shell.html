<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hedgewars Engine</title>
    <style>
      html, body { margin: 0; width: 100%; height: 100%; overflow: hidden; background: #0a0e14; }
      #canvas { width: 100vw; height: 100vh; display: block; }
      #status {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        color: #9fd7ff; font: 600 20px system-ui, sans-serif; text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="status">Loading engine...</div>
    <canvas id="canvas"></canvas>
    <script>
      var statusEl = document.getElementById('status');

      // Cache engine + data pack parts via service worker (works on https and localhost).
      (function () {
        if (!('serviceWorker' in navigator)) return;
        try {
          var swUrl = new URL('sw.js', window.location.href).href;
          var scopeUrl = new URL('./', window.location.href).pathname;
          navigator.serviceWorker.register(swUrl, { scope: scopeUrl }).catch(function () {});
        } catch (e) {}
      })();

      // Read config from URL param or localStorage
      var cfgParam = new URLSearchParams(window.location.search).get('cfg');
      var cfgB64 = cfgParam || localStorage.getItem('hw-wasm-webcfg64') || '';

      if (!cfgB64) {
        statusEl.textContent = 'No game configuration provided.';
      }

      function frontendUrl() {
        var base = window.location.pathname.replace(/\/hwengine\.html$/, '');
        return base + '/web-frontend/';
      }

      var didRequestFrontendReturn = false;
      function returnToFrontend(reason) {
        if (didRequestFrontendReturn) return;
        didRequestFrontendReturn = true;
        console.log('[engine] returning to frontend:', reason || 'exit');
        window.location.href = frontendUrl();
      }

      function getEngineAudioArgs() {
        var defaults = {
          engineVolume: 100,
          engineSoundEnabled: true,
          engineMusicEnabled: true,
          musicVolume: 70,
          sfxVolume: 80
        };
        var settings = defaults;

        try {
          var raw = localStorage.getItem('hw.settings');
          if (raw) {
            var parsed = JSON.parse(raw);
            settings = Object.assign({}, defaults, parsed || {});
          }
        } catch (e) {}

        function clampPercent(v, fallback) {
          var n = Number(v);
          if (!Number.isFinite(n)) return fallback;
          return Math.max(0, Math.min(100, Math.round(n)));
        }

        // Qt parity:
        // volume = slider(0..100) * 128 / 100, with separate nosound/nomusic.
        var master = clampPercent(
          settings.engineVolume,
          Math.max(
            clampPercent(settings.musicVolume, defaults.musicVolume),
            clampPercent(settings.sfxVolume, defaults.sfxVolume)
          )
        );
        var soundEnabled = settings.engineSoundEnabled !== false;
        var musicEnabled = settings.engineMusicEnabled !== false;

        var args = ['--volume', String(Math.floor(master * 128 / 100))];
        if (!musicEnabled) args.push('--nomusic');
        if (!soundEnabled) args.push('--nosound');
        return args;
      }

      var engineAudioArgs = getEngineAudioArgs();

      function shouldStartInFullscreen() {
        try {
          var raw = localStorage.getItem('hw.settings');
          if (!raw) return false;
          var s = JSON.parse(raw);
          return s && s.startInFullscreen === true;
        } catch (e) {
          return false;
        }
      }

      function maybeEnterFullscreen() {
        if (!shouldStartInFullscreen()) return;
        if (document.fullscreenElement) return;
        var canvas = document.getElementById('canvas');
        if (!canvas || !canvas.requestFullscreen) return;
        canvas.requestFullscreen().then(function() {
          window.removeEventListener('pointerdown', maybeEnterFullscreen);
          window.removeEventListener('keydown', maybeEnterFullscreen);
        }).catch(function() {
          // Keep listener so the user can retry on the next gesture.
        });
      }

      function buildArgs(encodedCfg) {
        var args = ['--prefix', '/Data', '--user-prefix', '/'].concat(engineAudioArgs);
        var chunkSize = 200;
        for (var i = 0; i < encodedCfg.length; i += chunkSize) {
          args.push('--webcfg64');
          args.push(encodedCfg.slice(i, i + chunkSize));
        }
        return args;
      }

      // Data pack splitting (hwengine.data.partN)
      //
      // The data loader generated by Emscripten in this repo calls `fetch(hwengine.data)`
      // and expects a normal Response body stream. It does NOT await
      // `Module.getPreloadedPackage()`, so we must not implement an async
      // getPreloadedPackage hook.
      //
      // Instead, intercept `fetch()` and, when a request targets `hwengine.data`, return a
      // Response that streams `hwengine.data.part0`, `part1`, ... sequentially.
      (function installSplitDataFetchHook() {
        if (typeof window !== 'object' || typeof window.fetch !== 'function') return;
        if (window.__hwSplitDataFetchHookInstalled) return;
        window.__hwSplitDataFetchHookInstalled = true;

        var originalFetch = window.fetch.bind(window);

        function isDataPackUrl(url) {
          var s = String(url || '');
          // Match ".../hwengine.data", optionally with query/hash.
          return /(^|\/)hwengine\.data([?#].*)?$/.test(s);
        }

        async function makeSplitDataResponse(baseUrl) {
          // Probe part0; if missing, treat as "not split" and let normal fetch handle it.
          var part0Url = baseUrl + '.part0';
          var r0 = await originalFetch(part0Url);
          if (!r0.ok) {
            if (r0.status === 404 || r0.status === 410) return null;
            throw new Error(String(r0.status) + ': ' + r0.url);
          }

          async function pumpResponseBody(resp, controller) {
            if (!resp.body || typeof resp.body.getReader !== 'function') {
              // Fallback path: buffer the whole part.
              var ab = await resp.arrayBuffer();
              controller.enqueue(new Uint8Array(ab));
              return;
            }
            var reader = resp.body.getReader();
            while (true) {
              var item = await reader.read();
              if (item.done) break;
              controller.enqueue(item.value);
            }
          }

          var stream = new ReadableStream({
            start: async function (controller) {
              try {
                await pumpResponseBody(r0, controller);
                for (var i = 1; ; i++) {
                  var partUrl = baseUrl + '.part' + i;
                  var r = await originalFetch(partUrl);
                  if (!r.ok) {
                    if (r.status === 404 || r.status === 410) break;
                    throw new Error(String(r.status) + ': ' + r.url);
                  }
                  await pumpResponseBody(r, controller);
                }
                controller.close();
              } catch (e) {
                controller.error(e);
              }
            }
          });

          return new Response(stream, {
            headers: {
              'Content-Type': 'application/octet-stream'
            }
          });
        }

        window.fetch = function (resource, init) {
          var url = (typeof resource === 'string')
            ? resource
            : (resource && typeof resource.url === 'string' ? resource.url : '');

          if (isDataPackUrl(url)) {
            return (async function () {
              var splitResp = await makeSplitDataResponse(url);
              if (splitResp) return splitResp;
              return originalFetch(resource, init);
            })();
          }

          return originalFetch(resource, init);
        };
      })();

      var Module = {
        canvas: document.getElementById('canvas'),
        noInitialRun: true,
        arguments: ['--prefix', '/Data', '--user-prefix', '/'].concat(engineAudioArgs),
        print: function(t) { console.log(t); },
        printErr: function(t) { console.error(t); },
        setStatus: function(t) {
          statusEl.textContent = t || '';
          if (!t) statusEl.style.display = 'none';
        },
        monitorRunDependencies: function(left) {
          if (left) {
            Module.setStatus('Loading data...');
          } else {
            Module.setStatus('');
          }
        },
        onExit: function(status) {
          console.log('[engine] onExit status=', status);
          returnToFrontend('onExit');
        },
        onAbort: function(reason) {
          console.error('[engine] abort:', reason);
          returnToFrontend('onAbort');
        },
        onRuntimeInitialized: function() {
          Module.setStatus('');
          if (cfgB64) {
            var args = buildArgs(cfgB64);
            console.log('[engine] launching with', args.length, 'args');
            Module.callMain(args);
          }
        }
      };

      // Unlock audio on first interaction
      function unlockAudio() {
        try {
          if (Module.SDL2 && Module.SDL2.audioContext && Module.SDL2.audioContext.state === 'suspended') {
            Module.SDL2.audioContext.resume();
          }
        } catch (e) {}
        window.removeEventListener('pointerdown', unlockAudio);
        window.removeEventListener('keydown', unlockAudio);
      }
      window.addEventListener('pointerdown', unlockAudio);
      window.addEventListener('keydown', unlockAudio);

      // If the user enabled "start game in fullscreen", enter fullscreen on first gesture.
      window.addEventListener('pointerdown', maybeEnterFullscreen);
      window.addEventListener('keydown', maybeEnterFullscreen);
    </script>
    {{{ SCRIPT }}}
  </body>
</html>
